import { stringifyMessage, error as outputError } from './output.js';
import { normalize } from './path.js';
import { Errors } from '@oclif/core';
export { ExtendableError } from 'ts-error';
export { AbortSignal } from 'abort-controller';
var FatalErrorType;
(function (FatalErrorType) {
    FatalErrorType[FatalErrorType["Abort"] = 0] = "Abort";
    FatalErrorType[FatalErrorType["AbortSilent"] = 1] = "AbortSilent";
    FatalErrorType[FatalErrorType["Bug"] = 2] = "Bug";
})(FatalErrorType || (FatalErrorType = {}));
export class CancelExecution extends Error {
}
/**
 * A fatal error represents an error shouldn't be rescued and that causes the execution to terminate.
 * There shouldn't be code that catches fatal errors.
 */
export class Fatal extends Error {
    constructor(message, type, tryMessage = null) {
        super(stringifyMessage(message));
        this.tryMessage = tryMessage ? stringifyMessage(tryMessage) : null;
        this.type = type;
    }
}
/**
 * An abort error is a fatal error that shouldn't be reported as a bug.
 * Those usually represent unexpected scenarios that we can't handle and that usually require some action from the developer
 */
export class Abort extends Fatal {
    constructor(message, tryMessage = null) {
        super(message, FatalErrorType.Abort, tryMessage);
    }
}
export class AbortSilent extends Fatal {
    constructor() {
        super('', FatalErrorType.AbortSilent);
    }
}
/**
 * A bug error is an error that represents a bug and therefore should be reported.
 */
export class Bug extends Fatal {
    constructor(message, tryMessage = null) {
        super(message, FatalErrorType.Bug, tryMessage);
    }
}
/**
 * A function that handles errors that blow up in the CLI.
 * @param error Error to be handled.
 * @returns A promise that resolves with the error passed.
 */
export async function handler(error) {
    let fatal;
    if (isFatal(error)) {
        fatal = error;
    }
    else if (typeof error === 'string') {
        fatal = new Bug(error);
    }
    else if (error instanceof Error) {
        fatal = new Bug(error.message);
        fatal.stack = error.stack;
    }
    else {
        // errors can come in all shapes and sizes...
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const maybeError = error;
        fatal = new Bug(maybeError?.message ?? 'Unknown error');
        if (maybeError?.stack) {
            fatal.stack = maybeError?.stack;
        }
    }
    await outputError(fatal);
    return Promise.resolve(error);
}
export function mapper(error) {
    if (error instanceof Errors.CLIError) {
        const mappedError = new Abort(error.message);
        mappedError.stack = error.stack;
        return Promise.resolve(mappedError);
    }
    else {
        return Promise.resolve(error);
    }
}
export function isFatal(error) {
    try {
        return Object.prototype.hasOwnProperty.call(error, 'type');
        // eslint-disable-next-line no-catch-all/no-catch-all
    }
    catch {
        return false;
    }
}
export function shouldReport(error) {
    if (!isFatal(error)) {
        return true;
    }
    if (error.type === FatalErrorType.Bug) {
        return true;
    }
    return false;
}
/**
 * Stack traces usually have file:// - we strip that and also remove the Windows drive designation
 *
 */
export function cleanSingleStackTracePath(filePath) {
    return normalize(filePath)
        .replace('file:/', '/')
        .replace(/^\/?[A-Z]:/, '');
}
//# sourceMappingURL=error.js.map