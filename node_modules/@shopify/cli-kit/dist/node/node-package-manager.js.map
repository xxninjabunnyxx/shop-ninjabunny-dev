{"version":3,"file":"node-package-manager.js","sourceRoot":"","sources":["../../src/node/node-package-manager.ts"],"names":[],"mappings":"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","sourcesContent":["import {exec} from '../system.js'\nimport {exists as fileExists, read as readFile} from '../file.js'\nimport {glob, dirname, join as pathJoin, findUp} from '../path.js'\nimport {Abort, Bug} from '../error.js'\nimport {latestNpmPackageVersion} from '../version.js'\nimport {Version} from '../semver.js'\nimport {content, token, debug} from '../output.js'\nimport {AbortController, AbortSignal} from 'abort-controller'\nimport type {Writable} from 'node:stream'\nimport type {ExecOptions} from '../system.js'\n\n/** The name of the Yarn lock file */\nexport const yarnLockfile = 'yarn.lock'\n\n/** The name of the pnpm lock file */\nexport const pnpmLockfile = 'pnpm-lock.yaml'\n\n/** An array containing the lockfiles from all the package managers */\nexport const lockfiles = [yarnLockfile, pnpmLockfile]\n\n/**\n * A union type that represents the type of dependencies in the package.json\n * - dev: devDependencies\n * - prod: dependencies\n * - peer: peerDependencies\n */\nexport type DependencyType = 'dev' | 'prod' | 'peer'\n\n/**\n * A union that represents the package managers available.\n */\nexport const packageManager = ['yarn', 'npm', 'pnpm'] as const\nexport type PackageManager = typeof packageManager[number]\n\n/**\n * Returns an abort error that's thrown when a directory that's expected to have\n * a package.json doesn't have it.\n * @param directory {string} The path to the directory that should contain a package.json\n * @returns {Abort} An abort error.\n */\nexport const PackageJsonNotFoundError = (directory: string) => {\n  return new Abort(`The directory ${directory} doesn't have a package.json.`)\n}\n\n/**\n * Returns a bug error that's thrown when the lookup of the package.json traversing the directory\n * hierarchy up can't find a package.json\n * @param directory {string} The directory from which the traverse has been done\n * @returns {Abort} An abort error.\n */\nexport const FindUpAndReadPackageJsonNotFoundError = (directory: string) => {\n  return new Bug(content`Couldn't find a a package.json traversing directories from ${token.path(directory)}`)\n}\n\n/**\n * Returns the dependency manager used to run the create workflow.\n * @param env {Object} The environment variables of the process in which the CLI runs.\n * @returns The dependency manager\n */\nexport function packageManagerUsedForCreating(env = process.env): PackageManager | 'unknown' {\n  if (env.npm_config_user_agent?.includes('yarn')) {\n    return 'yarn'\n  } else if (env.npm_config_user_agent?.includes('pnpm')) {\n    return 'pnpm'\n  } else if (env.npm_config_user_agent?.includes('npm')) {\n    return 'npm'\n  }\n  return 'unknown'\n}\n\n/**\n * Returns the dependency manager used by an existing project.\n * @param directory {string} The root directory of the project.\n * @returns The dependency manager\n */\nexport async function getPackageManager(directory: string): Promise<PackageManager> {\n  debug(content`Obtaining the dependency manager in directory ${token.path(directory)}...`)\n  const yarnLockPath = pathJoin(directory, yarnLockfile)\n  const pnpmLockPath = pathJoin(directory, pnpmLockfile)\n  if (await fileExists(yarnLockPath)) {\n    return 'yarn'\n  } else if (await fileExists(pnpmLockPath)) {\n    return 'pnpm'\n  } else {\n    return 'npm'\n  }\n}\n\ninterface InstallNPMDependenciesRecursivelyOptions {\n  /**\n   * The dependency manager to use to install the dependencies.\n   */\n  packageManager: PackageManager\n  /**\n   * The directory from where we'll find package.json's recursively\n   */\n  directory: string\n\n  /**\n   * Specifies the maximum depth of the glob search.\n   */\n  deep?: number\n}\n\n/**\n * This function traverses down a directory tree to find directories containing a package.json\n * and installs the dependencies if needed. To know if it's needed, it uses the \"check\" command\n * provided by dependency managers.\n * @param options {InstallNPMDependenciesRecursivelyOptions} Options to install dependencies recursively.\n */\nexport async function installNPMDependenciesRecursively(options: InstallNPMDependenciesRecursivelyOptions) {\n  const packageJsons = await glob(pathJoin(options.directory, '**/package.json'), {\n    ignore: [pathJoin(options.directory, 'node_modules/**/package.json')],\n    cwd: options.directory,\n    onlyFiles: true,\n    deep: options.deep,\n  })\n  const abortController = new AbortController()\n  try {\n    await Promise.all(\n      packageJsons.map(async (packageJsonPath) => {\n        const directory = dirname(packageJsonPath)\n        await installNodeModules({\n          directory,\n          packageManager: options.packageManager,\n          stdout: undefined,\n          stderr: undefined,\n          signal: abortController.signal,\n          args: [],\n        })\n      }),\n    )\n  } catch (error) {\n    abortController.abort()\n    throw error\n  }\n}\n\ninterface InstallNodeModulesOptions {\n  directory: string\n  args: string[]\n  packageManager: PackageManager\n  stdout?: Writable\n  stderr?: Writable\n  signal?: AbortSignal\n}\n\nexport async function installNodeModules(options: InstallNodeModulesOptions) {\n  const execOptions: ExecOptions = {\n    cwd: options.directory,\n    stdin: undefined,\n    stdout: options.stdout,\n    stderr: options.stderr,\n    signal: options.signal,\n  }\n  let args = ['install']\n  if (options.args) {\n    args = args.concat(options.args)\n  }\n  await exec(options.packageManager, args, execOptions)\n}\n\n/**\n * Returns the name of the package configured in its package.json\n * @param packageJsonPath {string} Path to the package.json file\n * @returns A promise that resolves with the name.\n */\nexport async function getPackageName(packageJsonPath: string): Promise<string | undefined> {\n  const packageJsonContent = await readAndParsePackageJson(packageJsonPath)\n  return packageJsonContent.name\n}\n\n/**\n * Returns the list of production and dev dependencies of a package.json\n * @param packageJsonPath {string} Path to the package.json file\n * @returns A promise that resolves with the list of dependencies.\n */\nexport async function getDependencies(packageJsonPath: string): Promise<{[key: string]: string}> {\n  const packageJsonContent = await readAndParsePackageJson(packageJsonPath)\n  const dependencies: {[key: string]: string} = packageJsonContent.dependencies ?? {}\n  const devDependencies: {[key: string]: string} = packageJsonContent.devDependencies ?? {}\n\n  return {...dependencies, ...devDependencies}\n}\n\n/**\n * Given an NPM dependency, it checks if there's a more recent version, and if there is, it returns its value.\n * @param dependency {string} The dependency name (e.g. react)\n * @param currentVersion {string} The current version.\n * @returns {Promise<string>} A promise that resolves with a more recent version or undefined if there's no more recent version.\n */\nexport async function checkForNewVersion(dependency: string, currentVersion: string): Promise<string | undefined> {\n  debug(content`Checking if there's a version of ${dependency} newer than ${currentVersion}`)\n  try {\n    const lastVersion = await latestNpmPackageVersion(dependency)\n    if (lastVersion && new Version(currentVersion).compare(lastVersion) < 0) {\n      return lastVersion\n    } else {\n      return undefined\n    }\n    // eslint-disable-next-line no-catch-all/no-catch-all\n  } catch (error) {\n    return undefined\n  }\n}\n\n/**\n * An interface that represents a package.json\n */\ninterface PackageJson {\n  /**\n   * The name attribute of the package.json\n   */\n  name?: string\n\n  /**\n   * The version attribute of the package.json\n   */\n  version?: string\n\n  /**\n   * The dependencies attribute of the package.json\n   */\n  dependencies?: {[key: string]: string}\n\n  /**\n   * The devDependencies attribute of the package.json\n   */\n  devDependencies?: {[key: string]: string}\n}\n\n/**\n * Reads and parses a package.json\n * @param packageJsonPath {string} Path to the package.json\n * @returns {Promise<PackageJson>} An promise that resolves with an in-memory representation\n *    of the package.json or rejects with an error if the file is not found or the content is\n *    not decodable.\n */\nexport async function readAndParsePackageJson(packageJsonPath: string): Promise<PackageJson> {\n  if (!(await fileExists(packageJsonPath))) {\n    throw PackageJsonNotFoundError(dirname(packageJsonPath))\n  }\n  return JSON.parse(await readFile(packageJsonPath))\n}\n\ninterface AddNPMDependenciesIfNeededOptions {\n  /** How dependencies should be added */\n  type: DependencyType\n\n  /** The dependency manager to use to add dependencies */\n  packageManager: PackageManager\n\n  /** The directory that contains the package.json where dependencies will be added */\n  directory: string\n\n  /** Standard output coming from the underlying installation process */\n  stdout?: Writable\n\n  /** Standard error coming from the underlying installation process */\n  stderr?: Writable\n\n  /** Abort signal to stop the process */\n  signal?: AbortSignal\n}\n\n/**\n * An interface that represents a dependency name with its version\n */\nexport interface DependencyVersion {\n  /**\n   * The name of the NPM dependency as it's reflected in the package.json:\n   *\n   * @example\n   *  In the example below name would be \"react\"\n   *  {\n   *    \"react\": \"1.2.3\"\n   *  }\n   */\n  name: string\n\n  /**\n   * The version of the NPM dependency as it's reflected in the package.json:\n   *\n   * @example\n   *  In the example below version would be \"1.2.3\"\n   *  {\n   *    \"react\": \"1.2.3\"\n   *  }\n   */\n  version: string | undefined\n}\n\n/**\n * Adds dependencies to a Node project (i.e. a project that has a package.json)\n * @param dependencies {string[]} List of dependencies to be added.\n * @param options {AddNPMDependenciesIfNeededOptions} Options for adding dependencies.\n */\nexport async function addNPMDependenciesIfNeeded(\n  dependencies: DependencyVersion[],\n  options: AddNPMDependenciesIfNeededOptions,\n  force = false,\n) {\n  debug(content`Adding the following dependencies if needed:\n${token.json(dependencies)}\nWith options:\n${token.json(options)}\n  `)\n  const packageJsonPath = pathJoin(options.directory, 'package.json')\n  if (!(await fileExists(packageJsonPath))) {\n    throw PackageJsonNotFoundError(options.directory)\n  }\n  const existingDependencies = Object.keys(await getDependencies(packageJsonPath))\n  let dependenciesToAdd = dependencies\n  if (!force) {\n    dependenciesToAdd = dependencies.filter((dep) => {\n      return !existingDependencies.includes(dep.name)\n    })\n  }\n  if (dependenciesToAdd.length === 0) {\n    return\n  }\n  let args: string[]\n  const depedenciesWithVersion = dependenciesToAdd.map((dep) => {\n    return dep.version ? `${dep.name}@${dep.version}` : dep.name\n  })\n  switch (options.packageManager) {\n    case 'npm':\n      args = argumentsToAddDependenciesWithNPM(depedenciesWithVersion, options.type)\n      break\n    case 'yarn':\n      args = argumentsToAddDependenciesWithYarn(depedenciesWithVersion, options.type)\n      break\n    case 'pnpm':\n      args = argumentsToAddDependenciesWithPNPM(depedenciesWithVersion, options.type)\n      break\n  }\n  options.stdout?.write(`Executing...${args.join(' ')}`)\n  await exec(options.packageManager, args, {\n    cwd: options.directory,\n    stdout: options.stdout,\n    stderr: options.stderr,\n    signal: options.signal,\n  })\n}\n\nexport async function addNPMDependenciesWithoutVersionIfNeeded(\n  dependencies: string[],\n  options: AddNPMDependenciesIfNeededOptions,\n) {\n  await addNPMDependenciesIfNeeded(\n    dependencies.map((dependency) => {\n      return {name: dependency, version: undefined}\n    }),\n    options,\n  )\n}\n\n// eslint-disable-next-line no-warning-comments\n// TODO: Switch it around so add-if-needed depends on this, rather than calling\n// if-needed with force: true which is counterintuitive.\nexport async function addLatestNPMDependencies(dependencies: string[], options: AddNPMDependenciesIfNeededOptions) {\n  await addNPMDependenciesIfNeeded(\n    dependencies.map((dependency) => {\n      return {name: dependency, version: 'latest'}\n    }),\n    options,\n    true,\n  )\n}\n\n/**\n * Returns the arguments to add dependencies using NPM.\n * @param dependencies {string[]} The list of dependencies to add\n * @param type {DependencyType} The dependency type.\n * @returns {string[]} An array with the arguments.\n */\nfunction argumentsToAddDependenciesWithNPM(dependencies: string[], type: DependencyType): string[] {\n  let command = ['install']\n  command = command.concat(dependencies)\n  switch (type) {\n    case 'dev':\n      command.push('--save-dev')\n      break\n    case 'peer':\n      command.push('--save-peer')\n      break\n    case 'prod':\n      command.push('--save-prod')\n      break\n  }\n  return command\n}\n\n/**\n * Returns the arguments to add dependencies using Yarn.\n * @param dependencies {string[]} The list of dependencies to add\n * @param type {DependencyType} The dependency type.\n * @returns {string[]} An array with the arguments.\n */\nfunction argumentsToAddDependenciesWithYarn(dependencies: string[], type: DependencyType): string[] {\n  let command = ['add']\n  command = command.concat(dependencies)\n  switch (type) {\n    case 'dev':\n      command.push('--dev')\n      break\n    case 'peer':\n      command.push('--peer')\n      break\n    case 'prod':\n      command.push('--prod')\n      break\n  }\n  return command\n}\n\n/**\n * Returns the arguments to add dependencies using PNPM.\n * @param dependencies {string[]} The list of dependencies to add\n * @param type {DependencyType} The dependency type.\n * @returns {string[]} An array with the arguments.\n */\nfunction argumentsToAddDependenciesWithPNPM(dependencies: string[], type: DependencyType): string[] {\n  let command = ['add']\n  command = command.concat(dependencies)\n  switch (type) {\n    case 'dev':\n      command.push('--save-dev')\n      break\n    case 'peer':\n      command.push('--save-peer')\n      break\n    case 'prod':\n      command.push('--save-prod')\n      break\n  }\n  return command\n}\n\n/**\n * Given a directory it traverses the directory up looking for a package.json and if found, it reads it\n * decodes the JSON, and returns its content as a Javascript object.\n * @param options {string} The directory from which traverse up.\n * @returns {Promise<{path: string; content: unknown}>} If found, the promise resolves with the path to the\n *  package.json and its content. If not found, it throws a FindUpAndReadPackageJsonNotFoundError error.\n */\nexport async function findUpAndReadPackageJson(fromDirectory: string): Promise<{path: string; content: unknown}> {\n  const packageJsonPath = await findUp('package.json', {cwd: fromDirectory, type: 'file'})\n  if (packageJsonPath) {\n    const packageJson = JSON.parse(await readFile(packageJsonPath))\n    return {path: packageJsonPath, content: packageJson}\n  } else {\n    throw FindUpAndReadPackageJsonNotFoundError(fromDirectory)\n  }\n}\n"]}