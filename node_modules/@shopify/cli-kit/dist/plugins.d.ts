import { JsonMap } from './json.js';
import { PickByPrefix } from './typing/pick-by-prefix.js';
import { MonorailEventPublic } from './monorail.js';
import { HookReturnPerTunnelPlugin } from './plugins/tunnel.js';
import { Interfaces } from '@oclif/core';
interface TunnelPlugin {
    start: (options: TunnelStartOptions) => Promise<string>;
}
interface TunnelStartOptions {
    port: number;
}
export declare function lookupTunnelPlugin(plugins: Interfaces.Plugin[]): Promise<TunnelPlugin | undefined>;
/**
 * Convenience function to trigger a hook, and gather any successful responses. Failures are ignored.
 *
 * Responses are organised into a dictionary, keyed by plug-in name. Only plug-ins that have hooks registered for the given event, and the hooks were run successfully, are included.
 */
export declare function fanoutHooks<TPluginMap extends HookReturnsPerPlugin, TEvent extends string & keyof TPluginMap>(config: Interfaces.Config, event: TEvent, options: TPluginMap[typeof event]['options'], timeout?: number): Promise<Partial<TPluginMap[typeof event]['pluginReturns']>>;
declare type AppSpecificMonorailFields = PickByPrefix<MonorailEventPublic, 'app_', 'project_type' | 'api_key' | 'partner_id'> & PickByPrefix<MonorailEventPublic, 'cmd_extensions_'> & PickByPrefix<MonorailEventPublic, 'cmd_scaffold_'>;
interface HookReturnsPerPlugin extends HookReturnPerTunnelPlugin {
    public_command_metadata: {
        options: {
            [key: string]: never;
        };
        pluginReturns: {
            '@shopify/app': Partial<AppSpecificMonorailFields>;
            [pluginName: string]: JsonMap;
        };
    };
    [hookName: string]: {
        options: {
            [key: string]: unknown;
        };
        pluginReturns: {
            [key: string]: JsonMap;
        };
    };
}
export declare type PluginReturnsForHook<TEvent extends keyof TPluginMap, TPluginName extends keyof TPluginMap[TEvent]['pluginReturns'], TPluginMap extends HookReturnsPerPlugin = HookReturnsPerPlugin> = TPluginMap[TEvent]['pluginReturns'][TPluginName];
export declare type FanoutHookFunction<TEvent extends keyof TPluginMap = string, TPluginName extends keyof TPluginMap[TEvent]['pluginReturns'] = string, TPluginMap extends HookReturnsPerPlugin = HookReturnsPerPlugin> = (this: Interfaces.Hook.Context, options: TPluginMap[TEvent]['options'] & {
    config: Interfaces.Config;
}) => Promise<PluginReturnsForHook<TEvent, TPluginName, TPluginMap>>;
export {};
