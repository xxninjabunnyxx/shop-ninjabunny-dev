/// <reference types="node" />
import { AbortSignal } from 'abort-controller';
import type { Writable, Readable } from 'node:stream';
export interface ExecOptions {
    cwd?: string;
    env?: {
        [key: string]: string | undefined;
    };
    stdin?: Readable | 'inherit';
    stdout?: Writable | 'inherit';
    stderr?: Writable | 'inherit';
    stdio?: 'inherit';
    input?: string;
    signal?: AbortSignal;
}
export declare type WritableExecOptions = Omit<ExecOptions, 'stdout'> & {
    stdout?: Writable;
};
export declare const open: (url: string) => Promise<void>;
/**
 * Runs a command asynchronously, aggregates the stdout data, and returns it.
 * @param command {string} Command to be executed.
 * @param args {string[]} Arguments to pass to the command.
 * @returns A promise that resolves with the aggregatted stdout of the command.
 */
export declare const captureOutput: (command: string, args: string[], options?: ExecOptions) => Promise<string>;
export declare const exec: (command: string, args: string[], options?: ExecOptions) => Promise<void>;
interface ConcurrentExecCommand {
    prefix: string;
    executable: string;
    args: string[];
    cwd: string;
}
/**
 * Runs commands concurrently and combines the standard output and error data
 * into a single stream that differenciates the sources using a colored prefix:
 *
 * Example:
 *   [my-extension] Log coming from my-extension
 *   [my-script] Log coming from my script
 *
 * If one of the processes fails, it aborts the running ones and exits with that error.
 * @param commands {ConcurrentExecCommand[]} Commands to execute.
 */
export declare const concurrentExec: (commands: ConcurrentExecCommand[]) => Promise<void>;
/**
 * Displays a large file using the terminal pager set by the user, or a
 * reasonable default for the user's OS:
 *
 * @param filename string The path to the file to be displayed.
 */
export declare function page(filename: string): Promise<void>;
export declare function sleep(seconds: number): Promise<unknown>;
export {};
