import { concurrent as concurrentOutput, shouldDisplayColors, debug } from './output.js';
import { platformAndArch } from './os.js';
import { Abort } from './error.js';
import { execa } from 'execa';
export const open = async (url) => {
    const externalOpen = await import('open');
    await externalOpen.default(url);
};
/**
 * Runs a command asynchronously, aggregates the stdout data, and returns it.
 * @param command {string} Command to be executed.
 * @param args {string[]} Arguments to pass to the command.
 * @returns A promise that resolves with the aggregatted stdout of the command.
 */
export const captureOutput = async (command, args, options) => {
    const result = await buildExec(command, args, options);
    return result.stdout;
};
export const exec = async (command, args, options) => {
    const commandProcess = buildExec(command, args, options);
    if (options?.stderr && options.stderr !== 'inherit') {
        commandProcess.stderr?.pipe(options.stderr);
    }
    if (options?.stdout && options.stdout !== 'inherit') {
        commandProcess.stdout?.pipe(options.stdout);
    }
    options?.signal?.addEventListener('abort', () => {
        commandProcess.kill('SIGTERM', { forceKillAfterTimeout: 1000 });
    });
    try {
        await commandProcess;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }
    catch (processError) {
        const abortError = new Abort(processError.message);
        abortError.stack = processError.stack;
        throw abortError;
    }
};
const buildExec = (command, args, options) => {
    const env = options?.env ?? process.env;
    if (shouldDisplayColors()) {
        env.FORCE_COLOR = '1';
    }
    const commandProcess = execa(command, args, {
        env,
        cwd: options?.cwd,
        input: options?.input,
        stdio: options?.stdio,
        stdin: options?.stdin,
        stdout: options?.stdout === 'inherit' ? 'inherit' : undefined,
        stderr: options?.stderr === 'inherit' ? 'inherit' : undefined,
    });
    debug(`
Running system process:
  · Command: ${command} ${args.join(' ')}
  · Working directory: ${options?.cwd ?? process.cwd()}
`);
    return commandProcess;
};
/**
 * Runs commands concurrently and combines the standard output and error data
 * into a single stream that differenciates the sources using a colored prefix:
 *
 * Example:
 *   [my-extension] Log coming from my-extension
 *   [my-script] Log coming from my script
 *
 * If one of the processes fails, it aborts the running ones and exits with that error.
 * @param commands {ConcurrentExecCommand[]} Commands to execute.
 */
export const concurrentExec = async (commands) => {
    await concurrentOutput(commands.map((command) => {
        return {
            prefix: command.prefix,
            action: async (stdout, stderr, signal) => {
                await exec(command.executable, command.args, {
                    stdout,
                    stderr,
                    cwd: command.cwd,
                    signal,
                });
            },
        };
    }));
};
/**
 * Displays a large file using the terminal pager set by the user, or a
 * reasonable default for the user's OS:
 *
 * @param filename string The path to the file to be displayed.
 */
export async function page(filename) {
    let executable;
    if (process.env.PAGER) {
        executable = process.env.PAGER;
    }
    else if ((await platformAndArch()).platform === 'windows') {
        executable = 'more';
    }
    else {
        executable = 'less -NR';
    }
    const [command, ...args] = [...executable.split(' '), filename];
    await exec(command, args, { stdout: 'inherit', stdin: 'inherit' });
}
export async function sleep(seconds) {
    return new Promise((resolve) => {
        setTimeout(resolve, 1000 * seconds);
    });
}
//# sourceMappingURL=system.js.map